<p>&#160; &#160; &#160; &#160;最近在复习python的基础知识，因为最初学python的时候，了解了基本的数据类型之后，就直接上框架了，所以基础很不扎实。这些天也踩了不少坑，今天来记录一下昨晚刚刚搞明白的单例模式😄</p>

<p></p>

<p>&#160; &#160; &#160; &#160;首先，啥是单例模式？单例模式实现了有啥意义？</p>

<p></p>

<p>&#160; &#160; &#160; &#160;<strong>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</strong></p>

<p></p>

<p>好，下面重点谈谈如何实现这个事情。</p>

<p></p>

<p>先看一段代码：</br>
<pre><code>
class Singleton(object):
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_instance'):
           orig = super(Singleton, cls)
          cls._instance = orig.__new__(cls, *args,  **kwargs)
        return cls._instance
</code></pre>

<p>&#160; &#160; &#160; &#160;这是众多单例模式的实现方法中较为典型的一种</p>
<p>&#160; &#160; &#160; &#160;这一段代码里，出现了之前很少用到的__new__()方法。毕竟一般在定义类的时候，我们都是上来就写__init__()方法，很少把__new__()方法拿出来。
这个__new__()方法，是一个类方法，__init__()方法中需要传入一个self参数对它进行初始化，但是前提是self得存在啊。那么self是从哪里来的呢？就是__new__()方法生成的。所以，new方法在
我们每次实例化一个类的时候,都会先于__init__()方法执行,并且每次都是向上代理,调用父类的__new__()方法,然后把自己传进去,生成一个实例.</p>
<p>&#160; &#160; &#160; &#160;好,这个单例不难理解,但现在把注意力放在其中的super()方法上.发现不对呀,super()方法还能这么玩?!以前的super方法,常见的形式是super(type, 实例名),而且一般这个
实例名都是self,这里咋会传cls进去?!翻了翻书,发现确实可以这样做,第二个参数既可以是实例,也可以是类.卧槽,第二个参数这么随便?!它到底是干啥使的?</p>
<p>&#160; &#160; &#160; &#160;当我们通过super函数调用__init__()或者__new__()方法时,第一个参数只是告诉super我们要找谁的父类，从而查找到我们想要去调用的方法，但是是谁去调用这个方法？是父类吗？不，是你指定的第二个参数，所以，第二个参数就是我们希望通过它调用对应方法的对象，在上述条件下，就是这个类本身。</p>
<p></strong>&#160; &#160; &#160; &#160;对上一段做个总结,那就是super()方法中,我虽然用的是父类的方法,但是调用方法的对象可以有很多，但凡是父类的子类，都可以调用它，究竟是谁来调用这个函数，我们在第二个参数处指定。嘿嘿嘿</strong></p>
<p>&#160; &#160; &#160; &#160;这里插播一条消息哔——————,既然都说到继承了,我们就想多一点.当我有一个父类的时候,我向上一瞅就找到爹了,但是万一我有很多个父类,抬头一看卧槽到底要找谁要我
想用的那个方法(属性)呢?这时候,就需要召唤神兽mro了啊哈哈哈哈</p>
<p><strong>&#160; &#160; &#160; &#160;MRO(方法解释顺序)就是为这个问题而生的.经典类和新式类有者不同的方法解释顺序.经典类的方法解释顺序为深度优先,新式类的解释顺序为广度优先.</strong></p>
<p>啥是深度优先,啥是广度优先?</p>
<p>首先看这一段代码:</p>
<pre><code>
class P1(object):
    def foo(self):
        print 'here is p1!'</p>
<p>class P2(object):
    def foo(self):
        print 'here is p2!'
    def bar(self):
        print 'bar!p2!'</p>
<p>class C1(P1, P2):
    pass</p>
<p>class C2(P1, P2):
    def bar(self):
        print 'bar!c2!'</p>
<p>class GC(C1, C2):
    pass</p>
<p>gc = GC()
gc.bar()
gc.foo()
</code></pre>
输出结果为:
<pre><code>
bar!c2!
here is p1!
</pre></code>
<p>注意,以上是新式类的查询结果,在众多父类当中,存在同名函数的时候,优先选择谁呢?顺序如下图!</p>
<img alt="示例图片1" src="http://7xl4oh.com1.z0.glb.clouddn.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%871.jpg" />
<p>没错!广度优先,就是同一个级别的类,必须从左到右全部查找一遍,确定找不到想要的方法/属性了,再往上走,同样是从左往右找,以此类推.</p>
<p>那么，啥是深度优先呢?</p>
<p>再看一段代码:</p>
<pre><code>
class P1:
    def foo(self):
        print 'here is p1!'


class P2:
    def foo(self):
        print 'here is p2!'
    def bar(self):
        print 'bar!p2!'


class C1(P1, P2):
    pass


class C2(P1, P2):
    def bar(self):
        print 'bar!c2!'

class GC(C1, C2):
    pass

gc = GC()
gc.bar()
gc.foo()
</pre></code>
<p>输出了啥？</p>
<p>锵锵锵！</p>
<pre><code>
bar!p2!
here is p1!
</pre></code>
<p>哈哈，这就是传说中的深度优先解释顺序，依然是从左往右，只是一股脑地往后找，当左边抵达最后时，不是从右边的第一个开始找，而是拐个弯，转到右边的最后一个，从后往前找，这就是“深度优先”啦！</p>
<p>上图！</p>
<img alt="示例图片2" src="http://7xl4oh.com1.z0.glb.clouddn.com/%E7%A4%BA%E4%BE%8B%E5%9B%BE%E7%89%872.jpg" />
