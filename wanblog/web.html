<p>&#160; &#160; &#160; &#160;前段时间有幸读到了一个非常好的系列文章————《一起写一个web服务器》，主要是介绍用python的模块写不同种类的简易的web服务器。其中包括了最原始的可以进行监听和发送的服务器，以及实现wsgi协议的web服务器，最后是一个可以实现处理并发请求的服务器。虽然功能都比较单一，但是该实现的都实现了。其中最后一个服务器花了我最多的时间，因为接触到的模块都比较陌生，google了挺久的。代码都在github上，不太清楚的地方都有中文的注释，好奇的小伙伴可以去看看😄</br>
<p><hr/>
&#160; &#160; &#160; &#160;硬广！<a href="https://github.com/wanzifa/WebServer/blob/master/webserver_final.py">丸子发的服务器练习</a></br>
<p><hr/>
&#160; &#160; &#160; &#160;这篇博客就围绕这个多进程服务器展开讨论啦～～～～～～</br>
<p><hr/>
&#160; &#160; &#160; &#160;第一弹～～～～～<strong>基础知识</strong>～～～～～～</br>
&#160; &#160; &#160; &#160;啥是进程？？？？</br>
&#160; &#160; &#160; &#160;进程从表面上来看，就是一条正在执行的程序。</br>
&#160; &#160; &#160; &#160;啥？没有了？？</br>
&#160; &#160; &#160; &#160;唔。。。。进程嘛，解释起来，还是一个比较有深度的概念。但是就这里提到的代码来说，理解到上句话这种程度就妥妥的啦。不过学习嘛，我们还是要有认真，所以进程的更进一步的解释————进程是一个正在执行的程序的实例，包括程序计数器，寄存器，变量的当前值。每个进程都拥有自己独立的虚拟cpu，真正的cpu在各进程之间来回切换。（读到这里，有点懵逼也没关系。但需要大家知道，所谓多进程，并不是真的许多进程在同一时刻跑。在任何一个给定的瞬间，其实只有一个进程在运行，多进程是通过运行进程的切换来实现的。因为切换的速度太快了，使得用户感觉不到进程变换的过程，就会造成一种许多进程一起跑跑跑的错觉～～～）。另外，进程与进程之间是独立的，它们无法访问对方的上下文，各自拥有自己的小天地～～～</br>
&#160; &#160; &#160; &#160;毕竟我们的py文件，跑起来的时候，被视为一个进程。我们的服务器是通过py文件来实现的，因此自然也是一个进程咯。那么如何把一个进程变为多个进程呢？答案就是python的os模块提供的这个神奇的方法————fork!</br>
&#160; &#160; &#160; &#160;哈哈，玩过github的大家是不是想到了fork代码仓库的fork？大差不差！这里的fork，同样有复制的意思！</br>
&#160; &#160; &#160; &#160;好的，我们上代码啦！</br>
(详尽的代码，<a href="https://github.com/wanzifa/WebServer/blob/master/webserver_final.py">丸子发的web服务器练习</a>上面已经给出啦，而且有注释哟，这里就不重复啦，我们挑核心内容来讲一下嘿嘿嘿)</br></p>

<p><hr />
<p>第二弹～～～～～<strong>上代码！</strong>！～～～～</br></p>
<pre><code> #创建子进程
 pid = os.fork()
    if pid == 0:
        listen_socket.close()
        handle_request(client_connection)
        client_connection.close()
        #退出子进程
        os._exit(0)
    else:
        client_connection.close()
</code></pre>
<p>美丽的fork小姐出场啦～～～～～</br>
那么fork小姐实现了什么呢？</br>
&#160; &#160; &#160; &#160;pid是进程id的意思。通过fork函数，可以复制当前的进程，创建一个和它一模一样的子进程。所以我们看到的虽然是一段代码，但其实从调用fork方法开始，就已经变成了同时跑着的父子两个进程，没错，它们跑的是同一段代码。不同的是，在父进程里，fork（）会返回子进程的pid，因此上段代码里，pid变量在父进程里是一个非0的数，一旦我们判断非0，那么就else啦，关闭父进程中处理客户端请求的socket连接，让它专心实现监听和accept功能。在子进程里，fork（）的返回值是0，因此pid如果等于0，就可以断定当前运行的是子进程啦，之后就让子进程去专心利用父进程监听和accept的socket对象对客户端请求进行处理。这样分工明确，父进程只监听，子进程只处理，hhhh，不管来多少个子进程，我fork一个新的让你自己玩，这些子进程之间相互是不干扰的，于是并发就实现啦～～～</br></p>
<hr />
<p>第三弹～～～～<strong>僵尸进程的消灭</strong>～～～～</br>
&#160; &#160; &#160; &#160;啦啦啦～～既然学会了创建子进程来实现多进程，是不是就大功告成了呢？</br>
&#160; &#160; &#160; &#160;并不！（不然干嘛开第三弹呢～～嘿嘿嘿）</br>
&#160; &#160; &#160; &#160;子进程虽好。但存在僵尸进程的问题。上一段代码是放在while语句中循环的，循环的是父进程，也就是说，父进程执行完else之后，还会继续跑，而子进程执行完if下面的一堆后，就自己退出了（os._exit()嘛～）。是不是退出了就万事大吉了？是不是退出了这个子进程就不碍事了呢？</br>
&#160; &#160; &#160; &#160;当然不！（不然干嘛开第三弹呢～～嘿嘿嘿）</br>
&#160; &#160; &#160; &#160;当一个子进程结束，而父进程却还在跑的时候，如果你不专门想办法告诉父进程“我已经结束了”这件事情，父进程是懵逼的。这时候，子进程的终止状态，pid，以及它的一些其他的信息就会被系统保留下来，痴痴的等父进程再回来获取它的这些信息。但是我们的父进程一心一意的往下跑，根本不可能再回来找它了呀。于是这些子进程，白白地用自己的相关信息占用着内存，就像僵尸一样什么用也没有，只知道吃内存，我们管这样的子进程叫做僵尸进程。</br>
&#160; &#160; &#160; &#160;僵尸进程的糟糕之处显而易见了，它占用内存，给父进程制造一种你内部还有我在跑的假象。这样一来，如果你的系统可用最大进程数设为400的话，虽然你本意是最多处理400个客户端请求，但基本上跑到200服务器就狗带了，因为每有一个请求进来，就会多一个僵尸进程，200个请求的时候，就有200个僵尸进程，一共400个进程已经上限了，fork函数就无法再创建新的进程处理别的请求了。</br>
&#160; &#160; &#160; &#160;僵尸进程这么可恶，如何结束它呢？</br>
上代码！</br></p>
<pre><code> #设置一个信号处理器，用于捕捉并处理已经结束的子进程.
signal.signal(signal.SIGCHLD, grim_reaper)</p>
<p>while True:
    try:
        client_connection, client_address = listen_socket.accept()
    except IOError as e:
        #IOError会返回一个错误对象，这个错误对象的args属性会返回一个错误码和对应的错误信息
        code, msg = e.args
        #EINTR错误会返回一个中断的系统调用的错误码
        if code == errno.EINTR:
            continue
        else:
            raise
</code></pre>
<p>我们引入了signal模块，它的第一个参数SGICHLD意味着这个信号处理器是用来捕捉子进程结束的信号的。一旦捕捉到了，这个信号就会被传递到第二个参数（一个回调函数）里，然后，跑这个回调函数，实现你的后续操作。</br>
&#160; &#160; &#160; &#160;后续操作是啥呢？</br>
&#160; &#160; &#160; &#160;锵锵锵！wait函数登场啦！</br>
<pre><code>#这个函数是捕捉到子进程退出信号后的处理函数
def grim_reaper(signum, frame):
    while True:
        try:
            #注意该函数与os.wait()的区别
            #os.wait()会形成在没有子进程结束的时候阻塞，这时候它什么也不返回，但进程不能干别的事情.
            #waitpid()中写入WNOHANG参数后，它就会在返回完所有的结束的子进程的终止信息之后，返回pid=0，不会阻塞进程.
            #第一个参数设置了waitpid函数不等待特定的子进程，而是等待并处理每一个子进程.
            pid, status = os.waitpid(
                -1,
                os.WNOHANG
            )
        except OSError:
            return</p>
<pre><code>    if pid == 0:
        return
</code></pre>
<p></code></pre>
在这个处理函数里，参数一用来识别信号，参数二用来获取信号出现时，进程栈的状况。这两个参数都是signal函数自行传递进去的，我们不必操心。</br>
&#160; &#160; &#160; &#160;这里需要提及wait函数和waitpid函数。两个函数其实是同样目的的不同实现。当调用os.wait()时，整个进程就会悬挂在这里，直到有子进程结束，这个函数会返回一个子进程的pid以及它的退出状态码，才会放剩下的代码运行。但是，注意我们这里是while语句，一旦我们跑到最后，没有子进程了，wait函数会一直阻塞在那里，整个程序就狗带了。所以我们要拒绝阻塞，于是不阻塞的waitpid函数就登场了。它同样是用来告知父进程子进程结束的函数，但是，我们可以在里面设置WHOHANG参数，从而实现它在没有已经结束的进程可以处理的时候，直接返回一个值为0的pid，而不是傻傻的阻塞。这里我们第一个参数－1意味着waitpid将等待处理任意一个已经结束的子进程。设置这一个参数，主要是因为当结束的子进程有许许多多一窝蜂涌向signal函数时，signal函数能力有限，它很可能只能捕捉到其中的一个结束信号，这时候调用处理函数时，需要处理函数一口气处理这个结束信号之前的许许多多个子进程，所以，哪管你谁是谁啊，是子进程我就要杀，就是这个意思。</br>
&#160; &#160; &#160; &#160;这么一来，所有的僵尸进程就死无葬身之地了，我们的的内存也干干净净啦，想跑多少个进程，就跑多少个进程啦啦啦啦啦啦～～～</br>
<img alt="僵尸进程狗带吧！" src="http://7xl4oh.com1.z0.glb.clouddn.com/%E8%BF%9B%E7%A8%8B%E5%8D%9A%E5%AE%A2.jpeg" /></p></p>
